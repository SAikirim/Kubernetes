---
01. 컨테이너와 쿠버네티스
	- 1.1 컨테이너의 개요
	  01. 컨테이너란?
		+ 호스트 OS상에 논리적인 구획을 만들고, 컨테이너 안에 필요한 것들을 모아, 전용 서버인 것 처럼 만듦
		+ 서버 가상화와 비교하여 가볍고 속도가 빠름
	  02. 컨테이너 어플리케이션 개발의 흐름
		+ 일반적인 웹 시스템 개발 시 필요한 어플리케이션
			= 어플리케이션 실행 모듈
			= 미들웨어나 라이브러리
			= OS/네트워크와 같은 인프라 환경 설정
		+ 기존 어플리케이션 개발
			= 개발 환경 -> 테스트 환경 -> 스테이징 환경 -> 실제 환경
		+ 컨네이터 어플리케이션
			= 빌드(build)
			= 공유(Ship)
			= 실행(Run)
	- 1.2 쿠버네티스의 개요
	  01. 분산환경에서 컨테이너 운용 관리
		+ 멀티호스트로 구성된 클러스터를 통합 관리하려면 컨테이너 오케스트레이션 툴이 필요
			= 쿠너네티스
			= 도커(Swarm 모드)
			= Apache Mesos/Marathon
	  02. 쿠버네티스의 특징
		+ 대규모 분산 환경에서 소수의 엔지니어만으로 컨테이너 어플리케이션을 관리하는 것을 목적으로한 오케스트레이션 툴
			- 정의 파일(선언적 설정)을 통해, 장애가 발생해도 사람의 개입없이 자동 수습 가능
		+ 구글 Brog에서 2015년 7월(버전 1.0)이 된 시점에 Linux Foundation 산하의 CNCF로 이관
		+ 주요 기능
			= 여러 서버에서의 컨테이너 관리
			= 컨테이너 배포
			= 컨테이너 간 네트워크 관리
			= 컨테이너의 부하분산
			= 컨테이너의 감시
			= 컨테이너 업데이트
			= 장애 발생 시 자동 복구
		+ Cloud Native Computing Foundation(CNCF)
			= 최첨단 클라우드 네이티브 컴퓨팅을 누구나 사용할 수 있도록하고 지속 가능하도록 하는 것이 목적
	  03. 쿠버네티스의 도입
		+ 온프레미스 환경에 도입
			= 하드웨어나 네트워크에 대한 지식이 필요
		+ 클라우드의 가상머신 인스턴트 구축
			= 인프라 환경 구축, 오케스트레이션 툴, 감시 툴 사용법, 시스템 운용 및 장애 대응 등 지식이 필요
		+ 퍼블릭 클라우드가 제공하는 '매니지드 서비스' 이용
			= 클러스터 버전업, 하드웨어 메인터넌스 작업 등 운영의 작업적인 부하를 경감
				-> 개발 업무 주력 가능
		+ Amazon Elastic Container Service for Kubernetes(Amazon EKS)
		+ Google Kubernetes Engine(GKE)
		+ Azure Kubernetes Service(AKS)
	  04. 쿠버네티스 유스케이스
		+ 기존 어플리케이션의 이전
		+ 마이크로 서비스의 운용 관리
		+ IoT 디바이스의 전개와 관리
		+ 기계학습의 워크로드
		
---		
02. 쿠버네티스의 환경 구축
	- 2.1 컨테이너 어플리케이션 개발의 흐름
	  01. 쿠버네티스를 사용한 개발 및 운용의 흐름
		+ 1. 개발환경의 준비 (명령의 설치 에디터/IDE)
		+ 2. 컨테이너 이미지 작성 및 공유
		+ 3. 클러스터 작성(실제 환경 작성)
	  02. Azure의 쿠버네티스 관련 서비스
		+ Azure Kuberetes Service(AKS), Azure Container Registry(ACR) 등
	- 2.2 개발 환경의 준비 
	  01. Visual Studio Code 설치
	  02. Azure CLI 명령의 설치
	  03. kubectl 명령의 설치
	  04. Azure Cloud Shell 이용
	- 2.3 컨테이너 이미지의 빌드와 공개  
	  01. Azure Container Registry(ACR)
		+ ACR은 Azure가 제공하는 컨테이너 이미지 공유 서비스
	  02. ACR을 사용한 컨테이너 이미지 빌드와 공유
		+ 레지스트리 작성
		+ 빌드할 샘플 다운로드
		+ 이미지 빌드
		+ 이미지 확인
	- 2.4 Azure를 사용한 쿠버네티스 클러스터 작성
	  01. AKS를 사용한 클러스터 구축
		+ ACR와 ASK 연결하기
		+ 클러스터 만들기
		+ 클러스터 연결을 위한 인증 정보 설정하기
	  02. kubctl 명령을 사용한 클러스터의 기본 조작

---	  
03. 쿠버네티스를 움직여 보자
	- 3.1 어플리케이션의 디플로이
	  01. 디플로이의 기본 흐름
		+ 매니페스트 파일 작성
		+ 클러스터에서 리소스 작성
		+ 어플리케이션의 동작 확인
	- 3.2 매니패스트 파일의 작성
	  01. 컨테이너 어플리케이션 설정하기
	  02. 서비스 설정하기
	- 3.3 클러스터에서 리소스 작성(apply)
	  01. 어플리케이션 디플로이하기
	  02. 서비스 공개하기 
	- 3.4. 어플리케이션의 동작 확인  
	
---	
04. 쿠버네티스의 요점
	- 4.1 쿠버네티스의 개념
		+ 쿠버네티스 지향점
			= 시스템 구축을 위한 수작업 줄이기
			= 시스템을 셀프 서비스로 운용
	  01. Immutable Infrastructure 
	  02. 선언적 설정
	  03. 자기 복구 기능
	- 4.2 쿠버네티스의 구조
	  01. 스케줄링과 디스커버리
		+ 스케줄링 : 알고리즘을 바탕으로 디플로이할 곳을 쿠버네티스가 자동으로 정함
		+ 서비스 디스커버리 : 쿠버네티스는 클러스트 안에 '구성 레지스트리'를 갖고 있어, 이를 바탕으로 서비스 디스커버리를 동적으로 수행함
	  02. 쿠버네티스의 서버 구성
		+ 마스터, 노드
	  03. 쿠버네티스의 컴포넌트
		+ 마스터
			= API Server
			= Scheduler
			= Controller Manger
			= etcd
	  04. 클러스터에 액세스하기 위한 인증 정보
		+ ~/.kube/config 
	- 4.3 쿠버네티스의 리소스
	  01. 어플리케이션 실행(Pod/ReplicaSet/Deployment)
		+ Pod(포드)
		+ ReplicaSet(레플리카 셋)
		+ Deployment(디플로이먼트, 전개)
		+ DaemonSet(데몬셋)
		+ StatefulSet(스테이트풀셋)
	  02. 네트워크 관리(Service/Ingress)
		+ Service(서비스)
		+ Ingress(인그레스)
	  03. 어플리케이션 설정 정보 관리(ConfigMap/Secrets)
		+ ConfigMap(컨피그맵)
		+ Secrets(시크릿)
	  04. 배치 잡 관리(Job/CronJob)
		+ Job(잡)
		+ CronJob(크론잡)
	  05. ETC(그 외 리소스)
		+ PV, PVC, Node, Namespace, ResourceQuota, NetworkPolicy, ServiceAccount, Role/ClusterRole, RoleBinding/ClusterRoleBinding 
	- 4.4 매니페스트 파일
	  01. 매니페스트 파일의 기본
		+ API의 버전 정보
		+ 리소스 종류
		+ 리소스 이름
		+ 리소스 상세 정보
	  02. YAML의 문법
	- 4.5 라벨을 사용한 리소스 관리
	  01. 라벨(Label)
		+ 많이 생성된 포드는 동일한 그룹으로 모아 조작할 수 있다면 편리
		+ 포드에 라벨을 붙이면 어떤 어플리케이션인지 식별할 수 있음
			= 개발, 테스트, 실제 환경 / 표시, 학습, 추론 기능
	  02. LabelSelector를 사용한 리소스 검색
	    + LabelSelector를 사용해 필터링 가능
		+ 쿠버네티스 리소스끼리 연결시킬 때 사용
	- 4.6 쿠버네티스의 리소스 분리
	  01 네임스페이스(Namespace)
		+ 가상적 분리 논리적 구분
		+ RBAC 권한 설정 가능
		+ 폴더에 비유 가능, 가상 공간 또는 그룹
		+ default, kube-public(컨피그맵과 같은 리소스), kube-system(클러스터가 내부에서 이용하는 리소스)
	
	
05. 컨테이너 어플리케이션의 실행
	- 5.1 포드를 사용한 컨테이너 어플리케이션의 관리
	  01. 포드
		+ 컨테이너에서는 '1컨테이너 1프로세스'가 원칙
		+ 컨테이너의 집합체가 '포드(Pod)'
		+ 포드의 성질
			= 하나 이상의 컨테이너, 동일한 노드, 포드 단위 스케일아웃, 네트워크와 스토리지 공유
		+ 네트워크
		+ 스토리지
	  02. 매니페스트 파일
		+ 포드의 매니페스트
	  03. 포드의 작성, 변경, 삭제	
	  04. 포드 디자인 패턴 
		+ 포드 작성 검토 포인트
			= 반드시 동일한 노드에서 실행할 필요가 있는지 없는지(프록시, OAuth인증)
			= 동일한 타이밍으로 스케줄링할 필요가 있는지 없는지(프론트엔드, 백엔드)
	- 5.2 포드의 스케줄링 구조
	  01. 포드가 어떻게 배치되는가?
		+ 스케줄링, API Server
		+ 스케줄링 흐름(기본 구조)
			1. kubectl 명령 실행
			2. 클러스터 구성 정보의 갱신
			3. 클러스터 구성 변경의 통지
			4. 포드의 작성
	  02. 포드를 배치하는 노드는 어떻게 정하는가? 
			1. kubectl 명령 실행
			2. 포드 정보 갱신
			3. 포드 정보 변경을 감지
			4. 포드를 할당/노드를 정함
			5. 노드의 할당 위치 갱신
			6. 포드 정보의 변경을 감지
			7. 포드 작성
	- 5.3 포드를 효울적으로 움직이자
		+ limit, request
	  05. 포드의 우선순위(QoS)
	- 5.4 포드를 감시하자
		+ Liveness Probe
	- 5.5 레플리카셋으로 여러 포드를 관리하자	
	  01. 레플리카셋(ReplicaSet)
	  02. 매니페스트 파일
	  03. 레플리카셋의 작성, 변경, 삭제
	  04. 클러스터 안의 상태를 어떻게 제어하는가?
	  05. 포드 장애가 발생하면 어떻게 될까?
	  06. 노드 장애가 발샐하면 포드는 어떻게 될까?
	- 5.6 부하에 따라 포드의 수를 바꿔 보자
	  01. 스케일러빌리티
	  02. 포드를 수동으로 수평 스케일하기
	  03. 포드를 자동으로 수평 스케일하기
	 
06. 어플리케이션 디플로이
	- 6.1 디플로이먼트를 사용한 어플리케이션 디플로이
	  01. 어플리케이션의 버전업 개념
		+ 롤링 업데이트
		+ 불루/그린 디플로이먼트
		+ 카나리아 릴리스(Canary Release)
	  02. 디플로이먼트
	  03. 매니페스트 파일
	- 6.2 디플로이먼트의 구조
	  01. 업데이트 처리 방식
		+ 리크리에이트(Recreate)
		+ 롤링 업데이트(RollongUpdate)
			= 롤아웃
			= 롤백
			= 롤아웃 조건
			= 롤링 업데이트 제어
	- 6.3 어플리케이션의 설정 정보를 관리하자
	  01. 어플리케이셔의 설정 정보 관리
		+ Configmap
		+ Secret
	
07. 아키텍처와 설계 원칙
	- 7.1 쿠버네티스의 아키텍처
	- 7.2 쿠버네티스의 설계 원칙
		+ Immutable Infrastructure, 선언적 설정, 자기 복구
	  01. Reconciliation Loops와 레벨 트리거 로직
		+ API Server에 조회하여 현재 상태와의 차이를 체크하는 루프(취득/조회 -> 대조 -> 실행)
	  02. API의 watch 옵션
	  03. 이벤트 체인
		+ 디플로이먼트는 레플리카셋과 그 실체인 포드와 의존 관계를 가짐
	- 7.3 서비스 제품의 구축
	
08. 가용성(Availability)
	- 8.1 쿠버네티스의 가용성
	  01. 마스터의 가용성(모두 액티브한 etcd와 API Server)
	  02. 마스터의 가용성(액티브/스탠바이 컴포넌트)
		+ 상태를 유지하는 루프 작동시, 동시에 작동되어 _경합_을 벌일 우러가 있음
		+ 'Endpoint 오브젝트'를 사용하여 리더 선출, 컨피그맵으로 대체될 예정
	  03. 노드의 가용성
	  04. 분산 수를 어떻게 할까? (마스터)
	  05. 분산 수를 어떻게 할까? (노드)
	- 8.2 인프라스트럭처의 시점
	  01. Blast Radius(폭발 반경)
		+ 분산 배치 레벨
			= 물리 서버(가상머신의 경우)
			= 랙
			= 데이터 센터
			= 지역
	  02. 소프트웨어적인 Blast Radius
		+ 클러스터 전체 영향 : '클러스터 다중화' 및 회피를 위한 '복수 클러스터 구현'을 생각할 수 있음
	  
09. 확장성(Scalability)
	- 9.1 쿠버네티스 노드의 수평 자동 스케일
	  01. Cluster Autoscaler
		+ 쿠버네티스의 애드온으로 개발
		+ 성능 및 부하에 따라 자동으로 노드를 늘리고 줄이는, 수평 자동 스케일 기능
	- 9.2 AKS에 있어서 Cluster Autoscaler
	- 9.3 기타 자동 스케일
	  01. HPA와 Cluster Autoscaler의 연동
		+ HPA
			= Metrics Server의 메트릭을 확인하여 정의한 대로 __포드__를 늘림(자기 일에만 집중)
		+ Cluster Autoscaler
			= (HPA에 의해) Pending 상태의 __노드__가 생기면 늘림
	  02. 쿠버네티스 외부의 메트릭을 사용한 자동 스케일
		+ Azure Service Bus Queue나 Event Hubs 등 Azure의 리소스 정보를 메트릭으로 도입하여 HPA가 포드의 증감 판단 재료로 사용 할 수 있음
		
10. 유지보수성(Manageability)
	- 10.1 쿠버네티스 운용에서 필요한 업데이트와 업그레이드 작업
	- 10.2 서버 업데이트
	  01. 노드 재시작의 영향을 최소한으로 하는 장치
		+ Cordon/Uncordon, Drain, PodDisruptionBudget
	  02. Cordon/Uncordon
		+ Cordon
			= '폐쇄한다'라는 뜻으로, 특정 노드를 스케줄 대상에서 제외시킴
		+ Uncordon
    		= 반대로 노드를 스케줄 대상으로 되돌림
	  03. Drain
		+ Cordon의 움직임에 _포드_의 삭제와 재작성을 더한 것
	  04. PodDisruptionBudget
		+ 일시적으로 사용할 수 없는 포드의 수나 비율을 컨트롤하는 장치
	  05. 노드 재시작을 자동으로 수행하려면
		+ Kured(Kubernetes Reboot Daemon) 사용, 데몬셋으로 구축됨
	- 10.3 쿠버네티스 컴포넌트 업데이트
	  01. kubeadm을 사용한 예(v1.10->v1.11)
	  02. 업그레이드 전략(인플레이스)
		+ 이미 움직이고 있는 클러스터를 업그레이드
	  03. 업그레이드 전략(블루/그린 디플로이먼트)
	  
	  
11. 리소스 분리(Security)
	- 11.1 쿠버네티스 리소스의 분리 단위
	- 11.2 네임스페이스를 사용하는 분리 
	- 11.3 쿠버네티스의 계정
	- 11.4 쿠버네티스의 인증과 인가
	- 11.5 RBAC(Role Based Access Control)
	- 11.6 리소스 이용량의 제한
	
12. 관측가능성(Observability)
