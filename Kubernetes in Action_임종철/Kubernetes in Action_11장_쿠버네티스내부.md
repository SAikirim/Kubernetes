# Kubernetes in Action

---
---
## 11장 쿠버네티스 내부

---
### 11.1 아키텍처 이해
* 클러스터는 두 부분으로 나뉨
	- 쿠버네티스 컨트롤 플레인
	- 워커노드

---
##### 컨트롤 플레인 컴포넌트
* API 서버 : 중앙 컴포넌트
* etcd 분산 스토어
* Controller Manger
* Scheduler

##### 워커노드를 실행하는 컴포넌트

##### 컴포넌트의 실행 방법
* Kubelet은 정규 시스템 컴포넌트이다.
	- 포드로서 모든 컨포넌트를 실행함
	- 포드로서 컨트롤 플레인을 실행시키 위해 마스터에도 배포됨

---
#### 11.1.2 쿠버네티스가 etcd를 사용하는 방법
*


###### 낙관적 동시성 제어(낙관적 잠금)에 관하여
* 데이터를 잠금고 읽지 못하게 하는 대신, 
	- 잠금이 필요한 위치에서 데이터의 업데이트가 필요하면, 
	- 해당 데이터 조각에 버전 번호를 포함하는 것
* 매번 데이터가 업데이트되면 버전 번호도 증가
* 데이터가 업데이트됬을 때, 클라이언트가 데이터를 읽는 시간과 업데이트 요청 시간 사이에 버전 번호가 증가하였는지 확인
	- 버전 정보가 증가하였으면, 업데이트 거절
	- 클라이언트는 새로운 데이터를 다시 읽고 업데이트를 다시 시도
* 그 결과 두 클라이언트가 같은 데이터를 업데이트를 시도시 오직 하나의 클라이언트만 성공하게 됨
```
모든 쿠버네티스 리소스에는 metadata.resourceVersion 필드가 있다．클라이언트는 오브젝트를
 업데이트할 때 API 서버로 다시 전달해야 한다．버전이 etcd에 저장된 것과 일치하는 것이 없다면 
 API 서버는 갱신을 거절한다，
```

Ex) 포드를 나타내는 etcd 엔트리
```
$ sudo ETCDCTL_API=3 ./etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key get /registry/pods/default/ngins-5f5678c9d8-5z8wv --prefix
```
* API 서버는 포드 및 전체 정보를 etcd에 JSON형식의 리소스로 저장함
	- etcd는 계층적 키 스토리지

##### 저장된 오브젝트의 일관성과 유효성 보장
* 구글의 오메가(Omega)
	- 중앙 집중식 스토리지 사용
	- 여러 컨트롤 플레인 컨포넌트가 스토리지에 직적 액세스함(쿠버네티스와 반대)
		+ 모든 컴포넌트 충돌을 올바르게 처리하기 위해 낙관적 잠금 메커니즘을 준수해야함
		+ 메커니즘을 완전히 준수하지 않으면 일관적인지 않는 데이터가 발생할 수 있음
* 쿠버네티스는 모든 컨트롤 플레인 컴포넌트가 API서버를 통과하도록 요구함으로써 낙관적 잠금 준수를 향상시킴
* API 서버는 스토리지에 기록된 데이터가 항상 유효하고 데이터의 변경 사항이 인증된 클라이언트에서만 수행되도록 함

##### etcd가 클러스터가 될 때 일관성 보장
* RAFT 합의 알고리즘을 사용

---
#### 11.1.3 API 서버가 하는 일
![API서버의 동작](./Kubernetes in Action_11장_쿠버네티스내부/11장_000_API서버의동작.png)

##### 인증 플러그인을 사용한 클라이언트 인증
* API서버는 요청을 보낸 클라이언트를 확인/결정할 때까지 차례로 플러그인를 호출함(인증)

##### 권한 승인 플러그인을 통한 클라이언트 승인
* 인증 플러그인과 마찬가지로 API 서버는 하나 혹은 그 이상의 '권한' 승인 플러그인을 사용할 수 있도록 설정 가능
* API 서버의 역할
	- 인증된 사용자가 요청된 '액션'을 요청된 리소스에 대해 수행할 수 있는지 결정하는 것
	- Ex) 포드를 생성할 때 API 서버는 모든 권한 승인 플러그인에게 차례대로 물어보고 사용자가 요청된 네임스페이스에 포드를 생성할 수 있는지 결정

##### 승인 제어 플러그인을 통해 요청 받은 리소스를 확인／수정
* 요청이 리소스를 생성, 수정, 삭제한다면, 요청은 '승인' 제어 플러그인으로 보내지게 됨

* Ex) 숭인 제어 플러그인
* AlwaysPulllmages: 포드를 배포될 때마다 이미지가 풀(pull)되도록 포드의 imagePullPolicy를 Always로 오버라이드함
* ServerAcoount: 명시적으로 설정하지 않은 포드로 기본 서비스 계정을 적용함
* NamespaceLifeCycle: 존재하지 않는 네임스페이스뿐만 아니라 삭제될 네임스페이스상의 포드 생성을 방지
* ResourceQuota: 특정 네임스페이스의 포드가 네임스페이스에 할당된 만큼의 CPU 및 메모리만사 용하는지 확인(14장 참고)

##### 리소스 검증 및 영구 저장
* 요청이 모든 승인 제어 플러그인을 통과하면,
	- API 서버는 오브젝트의 유효성을 검사하고, 
	- 이를 etcd에 저장한 다음 클라이언트에 응답함

---
#### 11.1.4 API 서버가 클라이언트의 리소스 변화를 감지하는 방법
* API 서버가 추가로 하는 일
	- 리소스 변화를 감지하기위해 컨트롤러와 다른 컴포넌트를 활성화하는 일을 함
	- 변화가 있을 때 통지하도록 요청함

![API서버 갱신 과정](./Kubernetes in Action_11장_쿠버네티스내부/11장_00_API서버갱신과정.png)

Ex) kubectl로 리소스 감시
```
kubectl get pods --watch
NAME                     READY   STATUS    RESTARTS   AGE
ngins-5f5678c9d8-5z8wv   1/1     Running   0          147m
...
```
* 감시 이벤트의 전체 YAML을 출력 가능
	- `kubectl get pods --watch -o yaml`

---
#### 11.1.5 스케줄러 이해
* 스케줄러가 하는 일
	- API 서버를 통해 포드의 정의를 업데이트
	-> 그 후, API 서버는 포드가 스케줄됐다고 Kubelet에게 통지
	-> 대상 노드의 Kubelet이 포드가 해당 노드에 스케줄됐음을 확인하자마자 포드의 컨테이너를 생성하고 실행함

##### 기본 스케줄러 알고리즘
![스케줄러 알고리즘](./Kubernetes in Action_11장_쿠버네티스내부/11장_01_스케줄러알고리즘.png)
1. 노드의 필터링
    * 포드에 NodSelector의 설정 확인
    * 포드에 설정된 '리소스 요구'와 현재 사용 가능한 '실제 리소스' 등 확인
        - 여러가지 확인 후 할당할 노드를 필터링함
        - Ex) 해당 노드에 라벨을 설정하여 포드의 매니페스트에서 명시적으로 고사양 노드에 스케줄링되도록 설정
2. 노드의 우선 순위
    * 우선 순위(0~10)를 바탕으로 배치할 노드를 정함
		- 다수의 노드가 가장 높은 점수를 갖는다면, '라운드 로빈'이 사용됨

##### 수용 가능한 노드 찾기
* 포드를 수용 가능한 노드인지 결정하기 위해 __스케줄러__는 구성된 각 술어 함수 목록을 통해 각 노드로 전달
	- 노드가 포드의 하드웨어 리소스 요청을 이행할 수 있을까? (14장 참고)
	- 노드에 리소스가부족한가? (메모리나 디스크의 부족상태를 보고하는가?)
	- 포드가 이름으로 특정 노드에 스케줄되도록 요청하는 경우, 이것은 노드인가?
	- 노드가 포드 스펙의 노드 셀렉터에 맞는 라벨을 가질 수 있을까? (하나라도 정의돼 있다면）
	- 포드가 특정 호스트 포트에 바인딩을 요청하는 경우(13장 참고）해당 노드에 포트가 이미 사용되고 있는가?
	- 포드가 특정 볼륨 유형을 요청하는 경우, 이 볼륨을 노드의 포드에 마운트할 수 있는가? 아니면 노드의 다른 포드에서 이미 동일한 볼륨을 사용하고 있는가?
	- 포드는 노드의 테인트(taints)를 허용하는가? (테인트와 톨러레이션은 16장 참고)
	- 포드가 노드나 포드의 친화성과 비친화성 규칙을 설정할 수 있을까？ 그렇다면 이 규칙을 어길 수 있는 노드로 포드가 스케줄돼야 한다. (16장 참고)
* 노드가 포드를 호스트할 수 있으려면 이런 모든 사항을 통과해야함
	- 이런 체크를 통과한 이후, 스케줄러는 노드의 서브세트를 끝냄


##### 포드를 위한 최적의 노드 선택
* 포드가 다수 실행된 노드보다 적게 실행된 노드를 선호
* 클라우드 인프라스트럭처에 의해 제공한다면, 비용절약을 위해 다수 실행된 노드를 선택할 수도 있음

##### 고급 포드 스케줄링
* 기본적으로 포드는 여러 개의 노드에 분산되어 동작함
	- 하지만 항상 그렇게 구성된다는 보장은 없음
* 포드가 클러스터에 분산되도록 강제하거나 포드 친화성 규칙을 정의함으로써 선로 인접하게 할 수는 있음
	- 16장 참고

##### 다중 스케줄러 사용
* 다중 스케줄러를 실행할 수 있음
	- 각 포드들의 포드 스펙에 schedulerName 속성을 설정해 특정 포드가 스케줄되도록 스케줄러를 지정 가능
	- 속성 설정이 없다면 기본 스케줄러 사용(schedulerName이 default-shceduler로 설정됨)
	
---
#### 11.1.6 컨트롤러 매니저에서 실행되고 있는 컨트롤러 소개
* 레플리케이션 매니저（레플리케이션컨트롤러 리소스의 컨트롤러）
* 레플리카셋, 데몬셋, 잡 컨트롤러
* 디플로이먼트 컨트롤러
* 스테이트풀셋 컨트롤러
* 노드 컨트롤러
* 서비스 컨트롤러
* 엔드포인트 컨트롤러
* 네임스페이스 컨트롤러
* 영구볼륨 컨트롤러
* 그밖의 컨트롤러

##### 컨트롤러가 하는 일과 동작 방식
* 모든 API 서버는 리소스의 변경을 감시하고 새로운 오브젝트를 생성하거나 갱신, 삭제 등의 변경을 위한 동작을 수행함

###### 컨트롤러의 소스 코드를 살펴보는 몇 가지 방법
참고 : https://github.com/kubernetes/kubernetes/tree/master/pkg/controller
```
각 컨트롤러는 일반적으로 Informer라는 컨스트럭터를 갖는다．이는 기본적으로 API 객체가 갱신되는
순간마다 불리는 리스너다．일 상적으로 Informer는 특정 타입의 리소스에 대한 변화를 대기한다．
생성자를 보면 컨트롤러가 보고 있는 리소스가 표시된다．
다음엔 worker( ) 메소드를 살펴보라．내부를 들여다 보면 컨트롤러가 무엇인가 원할 때마다 호출되는
메소드를 찾을 수 있다．통상적으로，실제 함수는 syncHandler나 이름이 유사한 필드에 저장이 된다．
이 필드는 생성자에서도 초기화되므로，여기서 호출되는 함수의 이름을 찾을 수 있다．그 함수는 모든
마법이 일어나는 장소다．
```

##### 레플리케이션 매니저
* 레플리케이션 매니저
	- 레플리케이션 컨트롤러 리소스를 움직이게 하는 컨트롤러
	- 실제 작업하는 것은 레플리케이션컨트롤러가 아니라 레플리케이션 매니저
	
![레플리케이션 매니저](./Kubernetes in Action_11장_쿠버네티스내부/11장_02_레플리케이션매니저.png)	
	
	
---
---
### 11.7 요약
* 

---
## 출처
[^출처]: Kubernetes in Action-마르코 룩샤-에이콘


<!-- ![](./Kubernetes in Action_11장_쿠버네티스내부/) -->